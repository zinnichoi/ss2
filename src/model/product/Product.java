package model.product;

import domainapp.basics.exceptions.ConstraintViolationException;
import domainapp.basics.model.meta.*;
import domainapp.basics.util.Tuple;
import model.bill.ProductOrder;

import java.util.List;

@DClass(schema = "internetCafe")
public abstract class Product {
    @DAttr(name = "productId", type = DAttr.Type.String, length = 10, auto = true, mutable = false, id = true, optional = false)
    private String productId;
    private static int idCounter = 0;
    @DAttr(name = "productName", type = DAttr.Type.String, length = 30, mutable = true, optional = false)
    private String productName;
    @DAttr(name = "productPrice", type = DAttr.Type.Integer, length = 10, mutable = true, optional = false)
    private Integer productPrice;
    @DAttr(name = "productCost", type = DAttr.Type.Integer, length = 10, mutable = true, optional = false)
    private Integer productCost;

    @DAttr(name = "productOrders", type = DAttr.Type.Collection, optional = false,
            serialisable = false, filter = @Select(clazz = ProductOrder.class))
    @DAssoc(ascName = "product-has-productOrders", role = "product",
            ascType = DAssoc.AssocType.One2Many, endType = DAssoc.AssocEndType.One,
            associate = @DAssoc.Associate(type = ProductOrder.class, cardMin = 0, cardMax = 25))
    private List<ProductOrder> productOrders;

    public Product(String productId, String productName, Integer productPrice, Integer productCost) {
        this.productId = nextID(productId);
        this.productName = productName;
        this.productPrice = productPrice;
        this.productCost = productCost;

    }

    public Product(String productName, Integer productPrice, Integer productCost) {
        this(null, productName, productPrice, productCost);
    }

    private String nextID(String currId) {
        if (currId == null) {
            idCounter++;
            return "P" + idCounter;
        } else {
            int num = Integer.parseInt(currId.substring(1));
            if (num > idCounter) {
                idCounter = num;
            }
            return currId;
        }
    }

    @DOpt(type = DOpt.Type.AutoAttributeValueSynchroniser)
    public static void updateAutoGeneratedValue(
            DAttr attrib,
            Tuple derivingValue,
            Object minVal,
            Object maxVal) throws ConstraintViolationException {

        if (minVal != null && maxVal != null) {
            //TODO: update this for the correct attribute if there are more than one auto attributes of this class

            String maxId = (String) maxVal;
            try {
                int maxIdNum = Integer.parseInt(maxId.substring(1));

                if (maxIdNum > idCounter) // extra check
                    idCounter = maxIdNum;

            } catch (RuntimeException e) {
                throw new ConstraintViolationException(
                        ConstraintViolationException.Code.INVALID_VALUE, e, new Object[]{maxId});
            }
        }
    }

    public String getProductId() {
        return productId;
    }


    public void setProductId(String productId) {
        this.productId = productId;
    }

    public String getProductName() {
        return productName;
    }

    public void setProductName(String productName) {
        this.productName = productName;
    }

    public Integer getProductPrice() {
        return productPrice;
    }

    public void setProductPrice(Integer productPrice) {
        this.productPrice = productPrice;
    }

    public Integer getProductCost() {
        return productCost;
    }

    public void setProductCost(Integer productCost) {
        this.productCost = productCost;
    }

    public List<ProductOrder> getProductOrders() {
        return productOrders;
    }

    public void setProductOrders(List<ProductOrder> productOrders) {
        this.productOrders = productOrders;
    }

    @DOpt(type = DOpt.Type.LinkAdder)
    //only need to do this for reflexive association: @MemberRef(name="enrolments")
    public boolean addProductBill(ProductOrder p) {
        if (!productOrders.contains(p))
            productOrders.add(p);
        return false;
    }

    @DOpt(type = DOpt.Type.LinkAdderNew)
    public boolean addNewProductBill(ProductOrder p) {
        productOrders.add(p);
        return false;
    }

    @DOpt(type = DOpt.Type.LinkAdder)
    public boolean addProductBill(List<ProductOrder> productOrders) {
        boolean added = false;
        for (ProductOrder p : productOrders) {
            if (!this.productOrders.contains(p)) {
                if (!added) added = true;
                this.productOrders.add(p);
            }
        }
        return false;
    }

    @DOpt(type = DOpt.Type.LinkAdderNew)
    public boolean addNewProductBill(List<ProductOrder> productOrders) {
        this.productOrders.addAll(productOrders);
        return false;
    }

    @DOpt(type = DOpt.Type.LinkRemover)
    public boolean removeProductBill(ProductOrder productOrder) {
        boolean removed = this.productOrders.remove(productOrder);
        return false;
    }

}
